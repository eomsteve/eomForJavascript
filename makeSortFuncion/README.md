# 정렬 - 자료구조

# 버블 정렬
서로 인접한 두 원소를 비교해서 일정한 기준을 만족하면 서로의 값을 교환하여 정렬하는 방식

## 특징

- 장점
    - 구현이 매우 간단하다
- 단점
    - 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
    - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열의 모든 요소들과 교환되어야 한다.
    - 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 경우가 생긴다.
- 일반적으로 자료의 교환작업이 이동작업보다 복잡하기 때문에 버블정렬은 단순성에도 불구하고 **거의 쓰이지 않는다.**

![https://upload.wikimedia.org/wikipedia/commons/5/54/Sorting_bubblesort_anim.gif](https://upload.wikimedia.org/wikipedia/commons/5/54/Sorting_bubblesort_anim.gif)

## 시간복잡도 : $O(n^2)$

- 비교횟수
    - 최상, 최악, 평균 모두 일정
    - $n(n-1)/2$
- 교환 횟수
    - 입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한번 교환하기 위하여 3번의 이동이 필요하므로 (비교횟수 * 3)번 = $3n(n-1)/2$

# 삽입 정렬
손 안의 카드를 정렬하는 방법과 유사하다.자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입 함으로써 완성하는 알고리즘

삽입 정렬은 두 번째 자료부터 시작(Key값도 두번째 자료부터 시작)하여 그 앞의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다. 

## 특징

- 장점
    - 안정한 정렬 방법 : 중복된 원소의 순서가 바뀌지 않음
    - 레코드의 수가 적을 경우 알고리즘이 매우 간단하므로 다른 정렬보다 유리할 수 있다.
    - 대부분의 레코드가 이미 정렬되어있는 경우에 매우 효율적일 수 있다.
- 단점
    - 비교적 많은 레코드의 이동을 포함한다
    - 레코드의 수가많고 크기가 클 경우 적합하지 않다
    
    ![https://media.vlpt.us/images/hwamoc/post/4baaa2bc-d48a-4f3b-a063-6538f6f59971/%EC%82%BD%EC%9E%851.gif](https://media.vlpt.us/images/hwamoc/post/4baaa2bc-d48a-4f3b-a063-6538f6f59971/%EC%82%BD%EC%9E%851.gif)
    

## 시간복잡도

- 최선의 경우(자료가 이미 정렬되어 있는 경우)
    - $O(n)$
- 최악의 경우(입력 자료가 역순일 경우)
    - $O(n^2)$
- 평균의 경우
    - $O(n^2)$

# 합병정렬(Merge Sort)

분할정복 알고리즘 기법을 사용해서 배열을 작게 나누어 분할한 뒤 다시 합치는 방식의 정렬

- 퀵 정렬보다 성능이 떨어진다.
- 데이터 크기만한 메모리 공간이 필요하다.
- 데이터의 상태에 별 영향을 받지 않는다.
- 안정적 정렬 :  중복값의 인덱스가 정렬시 변하지 않는다.(순서가 안변함)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Merge-sort-example-300px.gif/220px-Merge-sort-example-300px.gif)

### n-way 합병 정렬

1. 정렬되지 않은 리스트를 각각 하나의 원소만 포함하는 n개의 부분 리스트로 분할
2. 부분리스트가 하나만 남을 때 까지 반복해서 병합하며, 정렬된 부분을 부분리스트를 생성, 마지막 남은 부분 리스트가 정렬 리스트

### 2-way 합병 정렬

1. 리스트의 길이가 1이하이면 이미 정렬된 상태
2. 분할 : 정렬되지않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
3. 정복 : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
4. 결합 : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병(이때 정렬 결과는 임시 배열에 저장) 
5. 복사 : 임시 배열에 저장된 결과를 원래 배열에 복사

### 시간복잡도

n-way 합병 정렬의 시간복잡도 : $O(nlog_nn)$
# 퀵 정렬

하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법

분할 정복 알고리즘의 하나, 평균적으로 매우 빠른 수행속도를 자랑하는 정렬방법

- 분할 정복 방법
    - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음 결과를 모아 원래의 문제를 해결하는 방법
    - 순환호출을 이용하여 구현한다.

## 과정

1. 리스트안에 있는 요소 한개를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두피벗의 오른쪽으로 옮겨진다.
3. 피벗을 제외한 왼쪽 리스트와 오른쪽리스트를 다시 정렬한다.
    1. 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다.
    2. 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분리스트로 나누는 과정을 반복한다.
4. 부분 리스트들이 더 이상 분할이 불가능 할 때 까지 반복한다.

![https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort-concepts.png](https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort-concepts.png)

## 특징

- 장점
    - 속도가 빠르다: 시간복잡도가 $O(nlog_2n)$를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다
    - 추가 메모리공간을 필요로 하지 않는다 : 퀵 정렬은 $O(log N)$만큼의 메모리를 필요로 한다.
- 단점
    - 정렬된 리스트에 대해서는 불균형 분할에 의해 오히려 수행 시간이 더 많이 걸린다
    - 해결: 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할 할 수 있는 데이터를 선택한다. ex) 중간값을 피벗으로 선택

## 시간복잡도

- 최선의 경우 : $O(nlog_2n)$
- 최악의 경우 : $O(n^2)$
- 평균 : $O(nlog_2n)$
