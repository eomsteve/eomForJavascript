# 익명함수

익명함수는 재사용하지 않는, 한번만 사용할 함수를 위한 개념으로, 따로 함수의 이름을 갖지 않는다. 리터럴 방식으로 변수에 담겨 사용하는 함수이다.

```js
//익명 함수

const sayHello = function() {
  console.log("hello!");
}

sayHello(); // 출력: hello!
```
익명함수는 메모리 관리에 효과적인 방안이 될 수 있다. 일반 함수는 자바스크립트를 초기에 읽어올때 호이스팅 되지 않아 전체 자바스크립트 내에서 단 한번만 쓰이는 함수가 불필요하게 메모리를 차지할 필요가 없어진다.

단 한번만 사용되는(재사용이 팔요없는) 함수의 경우, 불필요한 시간동안 메모리를 차지하지 않도록 익명함수로 구현한다면, 정확히 해당 함수가 필요한 위치에서만 해당 함수가 구현되고 사라지면서 메모리를 아낄수 있게 된다.

# 즉시 실행 함수 표현(IIFE, Immediately Invoked Function Expression)

함수 정의와 동시에 즉시 호출되는함수를 즉시 실행함수라고 한다. 즉시 실행함수는 단 한번만호툴되며 다시 호출할 수 없다.

즉시 실행함수는 함수 이름이 없는 익명함수를 사용하는 것이 일반적이다. 

즉시 실행함수는 반드시 그룹연산자 `()`로 감싸야 한다. 

```js
(function(){
    console.log("hello")
}());

//즉시 실행함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.
var res = (function(){
    let a = 5;
    let b = 10;
    return a + b;
}());
console.log(res); // 15

res = (function(a,b){
    return a + b;
}(3, 5));
console.log(res); // 8
```

즉시실행함수 내에 코드를 모아두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있다.

# 함수 표현식과 함수 선언문

함수 선언문을 사용해 함수를 정의하는 방식은 아래와 같다. 
```js
function add(x, y){
    return x + y;
}
```
함수선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다. 

함수 선언문은 표현식이 아닌 문이다. 표현식이 아닌 문은 변수에 할당할 수 없다. 함수 선언문도 `표현식`이 아닌 `문` 이므로 변수에 할당할 수 없다.

```js
var add =function add (x, y){
    return x + y;
};

console.log(add(1,2));
```

하지만 이런식으로 선언문을 변수에 할당하듯 써도 자바스크립트는 오류를 내뱉지 않는다. 

자바스크립트 엔진이 코드의 문백에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우 혹은 표현식이 문인 함수 리터럴로 해석하는 경우가 있기 때문이다.

함수 선언문은 함수이름을 생략할 수 있다는 점을 제외하면 함수 리터럴과 형태가 동일하다. 
> 기명함수 리터럴은 함수 선원문 또는 함수 리터럴표현식으로 해석될 가능성이 있다.

자바스크립트 엔진은 생서왼 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당한다.

## 함수 표현식

함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의방식을 `함수 표현식` 이라 한다. 

```js
var add =function (x, y){
    return x + y;
};

console.log(add(1,2));
```

함수 리터럴의 함수 이름은 생략하는것이 일반적이다. 

## 함수 생성 시점과 호이스팅(선언문과 표현식)

함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점은 다르다.

```js
console.dir(add); // f add(x,y)
console.dir(sub); //undefined

console.log(add(5,7)); // 12
console.log(sub(5,7));//error

function add(x,y){//함수 선언문
    return x + y;
}

var sub = function(x,y){//함수 표현식
    return x - y;
}
```

즉, 코드가 한줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다.
따라서 함수 선언문이전에 함수를 참조할 수 있으며 호출할수도 있다. 

따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는것이 아니라 변수 호이스팅이 발생한다. 이때 변수는 함수 객체로서 할당이 안되었으므로 `undefined`
